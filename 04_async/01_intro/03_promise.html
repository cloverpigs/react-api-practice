<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>03_promise</title>
</head>
<body>

    <script>
        /* Promise는 콜백 지옥 같은 코드가 형성 되지 않게 하는 방안으로 ES6에서 도입 되었다. */    

        function increase(number) {
            /* promise 매개변수로 함수를 전달하는데 그 함수의 매개변수로 resolve와 reject를 전달한다. */
            /* resolve 는 성고, reject는 실패를 의미*/
            const promise = new Promise( ( resolve, reject ) => {
                setTimeout(
                    ()=> {
                        const result = number + 10;
                        if( result > 50 ) {
                            const e = new Error('NumberTooBig');
                            /* 실패 시 결과 값을 reject로 전달 */
                            return reject(e);
                        }

                        /* 성공 시 결과 값을 resolve의 인자로 전달 */
                        return resolve(result)
                    }
                    , 1000
                );
                
            } );

            return promise;
        }

        console.log(increase(0)); // promise 객체가 반환된다. 

        /* promise에서 resolve 함수로 전달한 값은 then 메소드에 전달하는 콜백 함수의 
        매개 변수를 이용해서 받아 올 수 있다. 
        비동기 작업을 연달아서 수행한다고 해서 콜백 지옥이 생기는 것이 아니라
        then 메소드를 통해 그 다음 작업을 설정하기 때문에 코드 가동성이 개선된다. */
        
        /* 콜백함수로 계속 부르는것이 아니라 then메소드의 리턴값 반환을 받고
        다시 then메소드로 그 값을 처리 하고 다시 리턴 받고 처리하고 하기 때문에
        콜백지옥이 아니고 코드도 가독성이 좋다.*/
        increase(0)
            .then( number => {
                console.log(number);

                return increase(number);  // 처리 후 다시 promise를 리턴한다. 
            })
            .then( number => {
                console.log(number);

                return increase(number);
            })
            .then( number => {
                console.log(number);

                return increase(number);
            })
            .then( number => {
                console.log(number);

                return increase(number);
            })
            .then( number => {
                console.log(number);

                return increase(number);
            })
            .catch( e => { // 에러가 발생하는 것을 catch에서 잡는다.
                console.log(e);
            })

    </script>
    
</body>
</html>